@startuml

class Juego {

    + jugar()
}

note top of Juego
    seudocodigo:

    public void jugar(){
        Partida partida = Partida.obtenerPartida();
        partida.jugar();
    }
end note

class Partida {
     -Mapa mapa
     -turno
     - partidaActual
     - partidasGuardadas
     - Partida()
     +{static}obtenerPartida():Partida
     + jugar()

}





note top of Partida
    seudocodigo:

    public final class Partida(){
        private static Partida partida;

        private Partida(){  //constructor

            Jugador primerJugador = new Jugador();
            Jugador segundoJugador = new Jugador();
            Mapa mapa = new Mapa();
            .....
            .....
        }

        public static Partida obtenerPartida(){
            if (partida == null){
                partida= new Partida();
            }
            return partida;
        }

        public void jugar(){

            primerJugador.asignarNombre();
            segundoJugador.asignarNombre();
            ....
            ....

        }
    }
end note

class Jugador {
    - nombre
    - color
    - raza
    - puntuacion

    + Jugador()
    + jugar()
    + asignarNombre(String):void
    + asignarColor(String):void
    + asignarRaza(Raza):void


}





class Turno {

   +avanzarTurno(Jugador)

}

class App{
    +start(Stage stage)
}


Juego "1"->"1"Partida

Partida<-Partida

Partida "1" *-down->"2"Jugador

App -> Juego



note "Aplicando patron Singleton" as N2
Partida .left. N2
N2 .. Juego



interface TipoAccion{
    +{abstract}realizarAccion()

}

class Avanzar{
    +realizarAccion()
}




class Recolectar{
    +realizarAccion()
}
class Atacar{
    +realizarAccion()
}
class Construir{
    +realizarAccion()
}
class Unidad{
    +realizarAccion()

}


TipoAccion<|.. Avanzar
TipoAccion<|.... Recolectar
TipoAccion<|.... Atacar
TipoAccion<|.. Construir
TipoAccion<|..right.. Unidad

abstract CrearAccion{
    +{abstract}crearAccion():TipoAccion
    + realizarAccion()
}
note top of CrearAccion
SeudoCodigo:

public class CrearAccion{

    public abstract TipoAccion crearAccion();

    public void realizarAccion(){
        ....
        ....
        TipoAccion unObjeto = crearAccion();
        unObjeto.realizarAccion();
        ....
        ....
    }
}

end note
class CrearAvanzar{
    +crearAccion():Avanzar
}
note left of CrearAvanzar
SeudoCodigo:

public class CrearAvanzar extends CrearAccion {

    @Override
    public TipoAccion crearAccion() {
        return new Avanzar();
    }
}

end note



class CrearRecolectar{
    +crearAccion():Recolectar
}
class CrearAtacar{
    +crearAccion():Atacar
}
class CrearConstruir{
    +crearAccion():Construir
}
class CrearUnidad{
    +crearAccion():Unidad
}

CrearAccion .right.> TipoAccion

CrearAccion <|-left- CrearAvanzar
CrearAccion <|--- CrearRecolectar
CrearAccion <|--- CrearAtacar
CrearAccion <|--- CrearConstruir
CrearAccion <|--- CrearUnidad


Jugador ....> CrearAccion: Aplicando patron Factory

note right of Jugador

    public class Jugador {
        ....
        ....

        private static CrearAccion accion;

        public void jugar() {
            if (...) { // podr√≠a ser un do-while
                accion = new CrearUnidad();
            } else {
                accion = new CrearConstruir();
            }

            accion.realizarAccion();
        }

        ....
        ....
        ....
    }
end note

@enduml